/*
 * generated by Xtext
 */
package de.wwu.md2.framework.scoping;

import java.util.Collection;
import java.util.Set;

import org.eclipse.emf.common.util.TreeIterator;
import org.eclipse.emf.ecore.EClass;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EReference;
import org.eclipse.emf.mwe2.language.scoping.QualifiedNameProvider;
import org.eclipse.xtext.naming.QualifiedName;
import org.eclipse.xtext.resource.IEObjectDescription;
import org.eclipse.xtext.scoping.IScope;
import org.eclipse.xtext.scoping.Scopes;
import org.eclipse.xtext.scoping.impl.AbstractDeclarativeScopeProvider;
import org.eclipse.xtext.scoping.impl.FilteringScope;

import com.google.common.base.Predicate;
import com.google.common.collect.Sets;
import com.google.inject.Inject;

import de.wwu.md2.framework.mD2.AbstractViewGUIElementRef;
import de.wwu.md2.framework.mD2.AttributeType;
import de.wwu.md2.framework.mD2.AutoGeneratedContentElement;
import de.wwu.md2.framework.mD2.ContainerElement;
import de.wwu.md2.framework.mD2.ContainerElementRef;
import de.wwu.md2.framework.mD2.ContentElement;
import de.wwu.md2.framework.mD2.ContentProvider;
import de.wwu.md2.framework.mD2.ContentProviderPathDefinition;
import de.wwu.md2.framework.mD2.DataType;
import de.wwu.md2.framework.mD2.Entity;
import de.wwu.md2.framework.mD2.EntityPathDefinition;
import de.wwu.md2.framework.mD2.MD2Package;
import de.wwu.md2.framework.mD2.ModelElement;
import de.wwu.md2.framework.mD2.NewObjectAtContentProviderAction;
import de.wwu.md2.framework.mD2.NewObjectEntityBinding;
import de.wwu.md2.framework.mD2.PathTail;
import de.wwu.md2.framework.mD2.ReferencedModelType;
import de.wwu.md2.framework.mD2.ReferencedType;
import de.wwu.md2.framework.mD2.ViewElementRef;
import de.wwu.md2.framework.mD2.ViewGUIElement;

/**
 * This class contains custom scoping description.
 * 
 * see : http://www.eclipse.org/Xtext/documentation/latest/xtext.html#scoping
 * on how and when to use it 
 *
 */
public class MD2ScopeProvider extends AbstractDeclarativeScopeProvider {
	
	@Inject
	private QualifiedNameProvider qualifiedNameProvider;
	
	public static Collection<EClass> validContainerForAbstractViews = Sets.newHashSet(MD2Package.eINSTANCE.getMain(), MD2Package.eINSTANCE.getWorkflowStep(), MD2Package.eINSTANCE.getSimpleAction());
	
	// Scoping for nested attributes
	IScope scope_PathTail_attributeRef(PathTail pathTail, EReference attributeRef) {
		Set<EObject> resultSet = Sets.newHashSet();
		EObject parent = pathTail.eContainer();
		if (parent instanceof PathTail) {
			AttributeType aType = ((PathTail) parent).getAttributeRef().getType();
			if (aType instanceof ReferencedType) {
				ModelElement modelElement = ((ReferencedType) aType).getEntity();
				if (modelElement instanceof Entity) {
					resultSet.addAll(((Entity) modelElement).getAttributes());
				}
			}
					
		} else if (parent instanceof ContentProviderPathDefinition) {
			DataType dType = ((ContentProviderPathDefinition) parent).getContentProviderRef().getType();
			if (dType instanceof ReferencedModelType) {
				ModelElement modelElement = ((ReferencedModelType) dType).getEntity();
				if (modelElement instanceof Entity) {
					resultSet.addAll(((Entity) modelElement).getAttributes());
				}
			}
		} else if (parent instanceof EntityPathDefinition) {
			resultSet.addAll(((EntityPathDefinition) parent).getEntityRef().getAttributes());		
		}
		return Scopes.scopeFor(resultSet);
	}
	
	// Scoping for entities that are proxies for auto-generated view elements
	IScope scope_EntityPathDefinition_entityRef(final AbstractViewGUIElementRef context, EReference entityRef) {
		Set<EObject> resultSet = Sets.newHashSet();
		if (context.getRef() instanceof AutoGeneratedContentElement && !isRestrictedToContainer(context)) {
			for (ContentProvider cp : ((AutoGeneratedContentElement) context.getRef()).getContentProvider()) {
				if (cp.getType() instanceof ReferencedModelType) {
					ModelElement m = ((ReferencedModelType) cp.getType()).getEntity();
					if (m instanceof Entity) {
						resultSet.add(m);
					}
				}
			}
		}
		return Scopes.scopeFor(resultSet);
	}
	
	//Scoping for target ContentProviders in NewObjectEntityBinding
	IScope scope_ContentProviderPathDefinition_contentProviderRef(final NewObjectEntityBinding context, EReference contentProviderRef) {
			Set<EObject> resultSet = Sets.newHashSet();
			NewObjectAtContentProviderAction newObjectAtContentProviderAction = (NewObjectAtContentProviderAction) context.eContainer();
			resultSet.add(newObjectAtContentProviderAction.getContentProvider());
			return Scopes.scopeFor(resultSet);			
	}
		
	// Scoping for referenced (to be copied) view elements
	IScope scope_AbstractViewGUIElementRef_ref(final EObject context, EReference ref) {
		IScope scope = delegateGetScope(context, ref);
		return new FilteringScope(scope, new Predicate<IEObjectDescription>() {
			@Override
			public boolean apply(IEObjectDescription input) {
				return isValidViewElement(context, input.getEObjectOrProxy());
			}
		});
	}	
	
	// Scoping for referenced (to be copied) view elements - 2. level
	IScope scope_AbstractViewGUIElementRef_ref(final AbstractViewGUIElementRef context, EReference ref) {
		if (context.eContainer() instanceof AbstractViewGUIElementRef) {
			// Obtain the type of the parent element
			AbstractViewGUIElementRef parent = (AbstractViewGUIElementRef) context.eContainer();
			if (isContentElement(parent)) {
				return IScope.NULLSCOPE;
			} else {
				final ContainerElement container;
				// Get the reference to the parent container
				if (parent.getRef() instanceof ViewElementRef) {
					container = (ContainerElement) ((ViewElementRef) parent.getRef()).getValue();
				} else if (parent.getRef() instanceof ContainerElementRef) {
					container = (ContainerElement) ((ContainerElementRef) parent.getRef()).getValue();
				} else {
					container = (ContainerElement) parent.getRef();	
				}
				IScope scope = delegateGetScope(context, ref);
				return new FilteringScope(scope, new Predicate<IEObjectDescription>() {
					@Override
					public boolean apply(IEObjectDescription input) {
						if (isValidViewElement(context, input.getEObjectOrProxy())) {
								TreeIterator<EObject> iter = container.eAllContents();
								while(iter.hasNext()) {
									EObject obj = iter.next();
									QualifiedName qualifiedName = qualifiedNameProvider.getFullyQualifiedName(obj);
									if (qualifiedName != null && qualifiedName.equals(input.getQualifiedName())) return true;									
								}
						}
						return false;
					}
				});
			}
		}
		return delegateGetScope(context, ref);
	}
	
//	// Scoping for referenced (to be copied) view elements in Workflows conditions
//	IScope scope_AbstractViewGUIElementRef_ref(final GuiElementStateExpression context, EReference ref) {
//		EObject parent = context;
//		while (parent.eContainer() != null) {
//			 parent = parent.eContainer();
//			 if (parent instanceof WorkflowStep) break;
//		}
//		IScope scope = delegateGetScope(context, ref);
//		if (parent == null) return scope;
//		final WorkflowStep step = (WorkflowStep) parent; 
//		return new FilteringScope(scope, new Predicate<IEObjectDescription>() {
//			@Override
//			public boolean apply(IEObjectDescription input) {
//				return (EcoreUtil.equals(step.getView().getRef(), input.getEObjectOrProxy()));
//			}
//		});
//	}	
		
	private static boolean isContentElement(AbstractViewGUIElementRef abtractRef) {
		EObject objInQuestion = abtractRef.getRef();
		if (abtractRef.getRef() instanceof ViewElementRef) {
			objInQuestion = ((ViewElementRef)abtractRef.getRef()).getValue();
		} else if (abtractRef.getRef() instanceof ContainerElementRef) {
			objInQuestion = ((ContainerElementRef)abtractRef.getRef()).getValue();			
		}
		return objInQuestion instanceof ContentElement;
	}

	private static boolean isRestrictedToContainer(EObject context) {
		while (context instanceof AbstractViewGUIElementRef) {
			context = context.eContainer();
		}
		return validContainerForAbstractViews.contains(context.eClass());
	}
	
	private static boolean isValidViewElement(EObject context, EObject obj) {
		if (obj instanceof ContainerElementRef || obj instanceof ViewElementRef || obj instanceof ViewGUIElement) {
			if (isRestrictedToContainer(context)) {
				if (obj instanceof ContentElement) return false;
				else if (obj instanceof ViewElementRef) {
					if (((ViewElementRef) obj).getValue() instanceof ContentElement) return false;
				}
			}
			return true;
		}
		return false;		
	}
}	
