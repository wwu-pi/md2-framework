package de.wwu.md2.framework.generator.util

import com.google.common.collect.Lists
import com.google.common.collect.Sets
import de.wwu.md2.framework.mD2.AbstractViewGUIElementRef
import de.wwu.md2.framework.mD2.ActionReference
import de.wwu.md2.framework.mD2.AlternativesPane
import de.wwu.md2.framework.mD2.AttrFloatMax
import de.wwu.md2.framework.mD2.AttrFloatMin
import de.wwu.md2.framework.mD2.AttrIntMax
import de.wwu.md2.framework.mD2.AttrIntMin
import de.wwu.md2.framework.mD2.AttrIsOptional
import de.wwu.md2.framework.mD2.AttrStringMax
import de.wwu.md2.framework.mD2.AttrStringMin
import de.wwu.md2.framework.mD2.Attribute
import de.wwu.md2.framework.mD2.AutoGeneratedContentElement
import de.wwu.md2.framework.mD2.BooleanType
import de.wwu.md2.framework.mD2.CallTask
import de.wwu.md2.framework.mD2.CheckBox
import de.wwu.md2.framework.mD2.CombinedAction
import de.wwu.md2.framework.mD2.ContainerElement
import de.wwu.md2.framework.mD2.ContainerElementRef
import de.wwu.md2.framework.mD2.ContainerElementType
import de.wwu.md2.framework.mD2.ContentElement
import de.wwu.md2.framework.mD2.ContentProviderPathDefinition
import de.wwu.md2.framework.mD2.Controller
import de.wwu.md2.framework.mD2.CustomAction
import de.wwu.md2.framework.mD2.CustomCodeFragment
import de.wwu.md2.framework.mD2.CustomizedValidatorType
import de.wwu.md2.framework.mD2.DateTimeType
import de.wwu.md2.framework.mD2.DateType
import de.wwu.md2.framework.mD2.Entity
import de.wwu.md2.framework.mD2.EntityPathDefinition
import de.wwu.md2.framework.mD2.Enum
import de.wwu.md2.framework.mD2.EnumType
import de.wwu.md2.framework.mD2.EventBindingTask
import de.wwu.md2.framework.mD2.EventUnbindTask
import de.wwu.md2.framework.mD2.FloatType
import de.wwu.md2.framework.mD2.FlowDirection
import de.wwu.md2.framework.mD2.FlowLayoutPane
import de.wwu.md2.framework.mD2.FlowLayoutPaneFlowDirectionParam
import de.wwu.md2.framework.mD2.GotoWorkflowStepAction
import de.wwu.md2.framework.mD2.GridLayoutPane
import de.wwu.md2.framework.mD2.IntegerType
import de.wwu.md2.framework.mD2.IsDateValidator
import de.wwu.md2.framework.mD2.IsIntValidator
import de.wwu.md2.framework.mD2.IsNumberValidator
import de.wwu.md2.framework.mD2.MD2Factory
import de.wwu.md2.framework.mD2.MappingTask
import de.wwu.md2.framework.mD2.Model
import de.wwu.md2.framework.mD2.ModelElement
import de.wwu.md2.framework.mD2.NamedColor
import de.wwu.md2.framework.mD2.NamedColorDef
import de.wwu.md2.framework.mD2.NotNullValidator
import de.wwu.md2.framework.mD2.NumberRangeValidator
import de.wwu.md2.framework.mD2.OptionInput
import de.wwu.md2.framework.mD2.PathTail
import de.wwu.md2.framework.mD2.ReferencedModelType
import de.wwu.md2.framework.mD2.ReferencedType
import de.wwu.md2.framework.mD2.RegExValidator
import de.wwu.md2.framework.mD2.SimpleDataType
import de.wwu.md2.framework.mD2.SimpleType
import de.wwu.md2.framework.mD2.Spacer
import de.wwu.md2.framework.mD2.StandardValidator
import de.wwu.md2.framework.mD2.StandardValidatorType
import de.wwu.md2.framework.mD2.StringRangeValidator
import de.wwu.md2.framework.mD2.StringType
import de.wwu.md2.framework.mD2.StyleBody
import de.wwu.md2.framework.mD2.StyleReference
import de.wwu.md2.framework.mD2.TabSpecificParam
import de.wwu.md2.framework.mD2.TextInput
import de.wwu.md2.framework.mD2.TextInputType
import de.wwu.md2.framework.mD2.TimeType
import de.wwu.md2.framework.mD2.UnmappingTask
import de.wwu.md2.framework.mD2.ValidatorBindingTask
import de.wwu.md2.framework.mD2.ValidatorType
import de.wwu.md2.framework.mD2.ValidatorUnbindTask
import de.wwu.md2.framework.mD2.ViewElementDef
import de.wwu.md2.framework.mD2.ViewElementEventRef
import de.wwu.md2.framework.mD2.ViewElementRef
import de.wwu.md2.framework.mD2.ViewElementType
import de.wwu.md2.framework.mD2.ViewGUIElement
import de.wwu.md2.framework.mD2.Workflow
import de.wwu.md2.framework.mD2.WorkflowStep
import java.util.Collection
import java.util.Collections
import java.util.HashMap
import java.util.List
import java.util.Map
import org.eclipse.emf.common.util.EList
import org.eclipse.emf.ecore.EObject
import org.eclipse.emf.ecore.resource.ResourceSet
import org.eclipse.emf.ecore.resource.impl.ResourceSetImpl
import org.eclipse.emf.ecore.util.EcoreUtil
import org.eclipse.xtext.naming.DefaultDeclarativeQualifiedNameProvider

import static extension de.wwu.md2.framework.generator.util.MD2GeneratorUtil.*
import static extension org.eclipse.emf.ecore.util.EcoreUtil.*

/**
 * Do a Model-to-Model transformation before the actual code generation process
 * to simplify the model.
 */
class PreprocessModel {
	
	public static String autoGenerationActionName = "autoGenerationAction"
	private static Map<NamedColor, String> colorNameHexMap
	
	def static ResourceSet preprocessModel(MD2Factory factory, ResourceSet input) {
		
		val workingInput = copyModel(input)
		
		initializeColorNameHexMap
		
		// Replace implicit Enum definitions with Enum model elements
		// Change AttributeType from EnumType to ReferencedType
		val Iterable<Attribute> enumAttributes = workingInput.resources.map(r|r.allContents.toIterable.filter(typeof(Attribute)).filter(attr | attr.type instanceof EnumType)).flatten.toList
		enumAttributes.forEach [ enumAttr |
			// Assume structure: Model -> Entity -> Attribute
			val parentEntity = enumAttr.eContainer as Entity
			val parentModel = parentEntity.eContainer as Model
			val curEnum = factory.createEnum()
			curEnum.name = parentEntity.name + "_" + enumAttr.name.toFirstUpper
			curEnum.enumBody = factory.createEnumBody()
			curEnum.enumBody.elements.addAll(Sets::newHashSet((enumAttr.type as EnumType).enumBody.elements))
			parentModel.modelElements.add(curEnum)
			
			// Replace EnumType with ReferencedType
			val refType = factory.createReferencedType()
			refType.entity = curEnum
			refType.many = enumAttr.type.many
			refType.params.addAll(Sets::newHashSet((enumAttr.type as EnumType).params.filter(typeof(AttrIsOptional))))
			enumAttr.type = refType
		]
		
		// Check for existence of flowDirection parameter for all FlowLayoutPanes.
		// Set default flowDirection (HORIZONTAL) if none has been specified by user.
		val Iterable<FlowLayoutPane> flowLayoutPanes = workingInput.resources.map(r|r.allContents.toIterable.filter(typeof(FlowLayoutPane))).flatten
		for (flowLayoutPane : flowLayoutPanes) {
			if(!flowLayoutPane.params.exists(p | p instanceof FlowLayoutPaneFlowDirectionParam)) {
				val flowDirectionParam = factory.createFlowLayoutPaneFlowDirectionParam
				flowDirectionParam.setFlowDirection(FlowDirection::HORIZONTAL)
				flowLayoutPane.params.add(flowDirectionParam)
			}
		}
		
		// Duplicate spacer according to the specified number of spacers
		val Iterable<Spacer> spacers = workingInput.resources.map(r|r.allContents.toIterable.filter(typeof(Spacer))).flatten
		for (spacer : spacers) {
			if(spacer.number > 1) {
				// if we found a spacer, get the list of its containing feature and replace the single spacer by
				// the specified number of spacers
				val lst = spacer.eContainer.eContainer.eGet(spacer.eContainer.eContainingFeature) as EList<Object>
				val idx = lst.indexOf(spacer.eContainer)
				var i = 0
				while(i < spacer.number) {
					val newSpacer = factory.createSpacer
					newSpacer.setNumber(1)
					val newViewElementType = factory.createViewElementDef
					newViewElementType.value = newSpacer
					lst.add(idx, newViewElementType)
					i = i + 1
				}
				spacer.eContainer.remove
			}
		}
		
		// Replace all named colors by their hex color equivalents
		val Iterable<NamedColorDef> namedColorDefs = workingInput.resources.map(r|r.allContents.toIterable.filter(typeof(NamedColorDef))).flatten
		for (namedColorDef : namedColorDefs) {
			val hexColorDef = factory.createHexColorDef
			hexColorDef.color = colorNameHexMap.get(namedColorDef.color)
			namedColorDef.replace(hexColorDef)
		}
		
		// Merge nested workflows
		val Iterable<Workflow> workflows = workingInput.resources.map(r|r.allContents.toIterable.filter(typeof(Workflow))).flatten
		val Iterable<GotoWorkflowStepAction> gotoWfStepAction = workingInput.resources.map(r|r.allContents.toIterable.filter(typeof(GotoWorkflowStepAction))).flatten
		for (workflow : workflows) {
			workflow.processWorkflowMerging(gotoWfStepAction, factory)
		}
		
		// Create CustomAction named autoGenerationAction for mappings and validators
		if (getAutoGenAction(workingInput) == null) {
			val ctrl = workingInput.resources.map(r|r.allContents.toIterable.filter(typeof(Controller))).flatten.last
			if (ctrl != null) {
				val autoGenAction = factory.createCustomAction();
				autoGenAction.name = autoGenerationActionName
				ctrl.controllerElements.add(autoGenAction)
			}
		}
		
		// Replace CombinedAction with CustomAction
		val Iterable<CombinedAction> combinedActions = workingInput.resources.map(r|r.allContents.toIterable.filter(typeof(CombinedAction))).flatten
		combinedActions.forEach [ combinedAction |
			// Assume structue: Controller -> Action
			val parentController = combinedAction.eContainer as Controller
			val custAction = factory.createCustomAction()
			custAction.name = combinedAction.name
			combinedAction.actions.forEach [ actionRef |
				val callTask =  factory.createCallTask()
				callTask.action = factory.createActionReference()
				(callTask.action as ActionReference).actionRef = actionRef
				custAction.codeFragments.add(callTask)
			]
			parentController.controllerElements.add(custAction)
			//combinedAction.remove()
		]
		
		// Mapping of cloned (key) and original (value) elements
		val HashMap<EObject, EObject> clonedElements = newHashMap()
		
		// Create view elements for AutoGeneratorPane and add MappingTasks
		val Iterable<AutoGeneratedContentElement> autoGenerators = workingInput.resources.map(r|r.allContents.toIterable.filter(typeof(AutoGeneratedContentElement))).flatten
		// autoGenerators to remain as view, because new (superfluous) generators might be created later when resolving view references (generators are only deleted at the end)
		// toList only for iteration without concurrent modification
		autoGenerators.toList.forEach [ autoGenerator | 
			// Assume structure: ContainerElement -> ViewElementType -> AutoGeneratedContentElement
			val parentContainer = autoGenerator.eContainer.eContainer as ContainerElement
			// No common supertype with attribute elements
			val List<ViewElementType> elements = switch (parentContainer) {
				GridLayoutPane: (parentContainer as GridLayoutPane).elements
				FlowLayoutPane: (parentContainer as FlowLayoutPane).elements
			}
			val pos = elements.indexOf(autoGenerator.eContainer)
			autoGenerator.contentProvider.forEach [
				val ContentProviderPathDefinition pathDefinition = factory.createContentProviderPathDefinition()
				pathDefinition.setContentProviderRef(it)
				switch (it.type) {
					ReferencedModelType: {
						val modelElement = (it.type as ReferencedModelType).entity
						val Collection<EntityPathDefinition> filteredAttributes = newHashSet()
						if (autoGenerator.filteredAttributes.size > 0) {
							if (autoGenerator.exclude) {
								filteredAttributes.addAll(autoGenerator.filteredAttributes) 
							} else {
								val entityPathDefinition = factory.createEntityPathDefinition()
								entityPathDefinition.entityRef = modelElement as Entity
								filteredAttributes.addAll(entityToPathDefinition(factory, entityPathDefinition, modelElement as Entity))
								val iter = filteredAttributes.iterator
								while (iter.hasNext) {
									val obj = iter.next
									var continue = false
									for (includePathDefinition : autoGenerator.filteredAttributes) {
										if (!continue && obj.equals(includePathDefinition)) {
											iter.remove
											continue = true
										} 
									}
								} 
							}
						}
						val Collection<ViewElementDef> viewDefs = modelToView(factory, workingInput, modelElement, pathDefinition, filteredAttributes).toList						
						elements.addAll(pos, viewDefs);
						// do not remove autoGenerator here, because its containment hierarchy is still needed for resolving GUI references
						// autoGenerators will be removed at the end of preprocessing
						
//						if (it.type.many) {
//							pathDefinition.tail = factory.createPathTail()
//							pathDefinition.tail.attributeRef = {
//								val AttributeType attr = (modelElement as Entity).attributes.filter([!filteredAttributes.map([it.referencedAttribute]).toList.contains(it)]).map([it.type]).findFirst([!it.eAllContents.filter(typeof(AttrIdentifier)).empty])
//								if (attr != null) attr.eContainer as Attribute else (modelElement as Entity).attributes.head
//							}
//							val viewElementDef = factory.createViewElementDef()					
//							viewElementDef.value = factory.createEntitySelector()
//							viewElementDef.value.name = modelElement.name.toFirstLower + "EntitySelector"
//							(viewElementDef.value as EntitySelector).textProposition = pathDefinition
//							elements.add(pos, viewElementDef);
//						}					
					}
					SimpleType: {
						val simpleDataType = (it.type as SimpleType).type
						var ViewElementDef viewDef = modelToView(factory, workingInput, simpleDataType, pathDefinition)
						// TODO: Generate EntitySelector
						//if (it.type.many) viewDef = wrapIntoMultiPane(factory, viewDef, simpleDataType.name + "MultiPane")
						elements.add(pos, viewDef); // do not remove autoGenerator here
					}
				}
			]
		]
		
		// Clone nested ContainerElement references into parent container
		val Iterable<ContainerElementRef> containerRefs = workingInput.resources.map(r|r.allContents.toIterable.filter(typeof(ContainerElementRef))).flatten.toList
		containerRefs.forEach [ containerRef |
			val containerDef = factory.createContainerElementDef()
			containerDef.value = copyElement(containerRef.value, clonedElements) as ContainerElement
			if (containerRef.rename) containerDef.value.name = containerRef.name
			containerRef.params.forEach [ param |
				val newParam = copyElement(param) as TabSpecificParam
				switch (containerDef.value) {
					GridLayoutPane: (containerDef.value as GridLayoutPane).params.add(newParam)
					FlowLayoutPane: (containerDef.value as FlowLayoutPane).params.add(newParam)
					AlternativesPane: (containerDef.value as AlternativesPane).params.add(newParam)
				}
			]
			val EList<EObject> elements = containerRef.eContainer.eGet(containerRef.eContainingFeature) as EList<EObject>
			elements.add(elements.indexOf(containerRef), containerDef)
		]
		
		// Clone nested ViewElement references into parent container
		var repeat = true
		val Collection<ViewElementRef> viewRefsDone = newHashSet()
		while (repeat) {
			val Iterable<ViewElementRef> viewRefs = workingInput.resources.map(r|r.allContents.toIterable.filter(typeof(ViewElementRef))).flatten.toList.sort(
				[obj1, obj2 |
					return countContainers(obj2,0)-countContainers(obj1,0)
				])
			val size = viewRefsDone.size 
			viewRefs.forEach [ viewRef |
				if (!viewRefsDone.contains(viewRef)) {
					val viewDef = factory.createViewElementDef()
					viewDef.value = copyElement(viewRef.value, clonedElements) as ViewGUIElement
					if (viewRef.rename) viewDef.value.name = viewRef.name
					val EList<EObject> elements = viewRef.eContainer.eGet(viewRef.eContainingFeature) as EList<EObject>
					elements.add(elements.indexOf(viewRef), viewDef)
					viewRefsDone.add(viewRef)
				}
			]
			// For the lack of mutable Booleans
			repeat = (viewRefsDone.size != size)
		}
		
		// Replace style reference with referenced style definition
		val styleRefs = workingInput.resources.map(r|r.allContents.toIterable.filter(typeof(StyleReference))).flatten.toList
		styleRefs.forEach[ styleRef |
			val styleDef = factory.createStyleDefinition()
			styleDef.definition = copyElement(styleRef.reference.body) as StyleBody
			styleRef.replace(styleDef)
		]
		
		// Simplify references to AbstractViewGUIElements (auto-generated and/or cloned)
		// Set ViewGUIElement to head ref  
 		val Iterable<AbstractViewGUIElementRef> abstractRefs = workingInput.resources.map(r|r.allContents.toIterable.filter(typeof(AbstractViewGUIElementRef)).filter([!(it.eContainer instanceof AbstractViewGUIElementRef)])).flatten
		abstractRefs.forEach [ abstractRef |
				abstractRef.ref = resolveAbstractViewGUIElementRef(workingInput, abstractRef, null, clonedElements)
				abstractRef.tail?.remove
				abstractRef.path?.remove
				abstractRef.simpleType?.remove
		]
		
		// Copy user-specified and auto-generated mappings from original to cloned GUI elements
		// Restricted to StartupActions and AutoGeneratedAction		
		var Collection<MappingTask> mappingTasks = workingInput.resources.map(r|r.allContents.toIterable.filter(typeof(MappingTask)).filter([isCalledAtStartup(it)])).flatten.toList
		val Collection<MappingTask> userMappingTasks = newHashSet()
		val Collection<MappingTask> autoMappingTasks = newHashSet()
		mappingTasks.forEach [ mappingTask |
			val mappingAction = mappingTask.eContainer as CustomAction
			var mappingTasksCollection = if (mappingAction == getAutoGenAction(workingInput)) autoMappingTasks else userMappingTasks
			for (entry : clonedElements.entrySet) {
				if (entry.value == mappingTask.referencedViewField.resolveViewGUIElement) {		
					val newTask = copyElement(mappingTask) as MappingTask
					val newAbstractRef = factory.createAbstractViewGUIElementRef()
					newAbstractRef.ref = entry.key
					newTask.referencedViewField = newAbstractRef
					mappingAction.codeFragments.add(newTask)
					mappingTasksCollection.add(newTask)
				}
			}
			mappingTasksCollection.add(mappingTask)
		]
		
		// Remove auto-generated mapping if unmapped or user-specified mapping is found 
		// Restricted to StartupActions
		val Collection<UnmappingTask> unmappingTasks = workingInput.resources.map(r|r.allContents.toIterable.filter(typeof(UnmappingTask)).filter([isCalledAtStartup(it)])).flatten.toList	
		val iterator = autoMappingTasks.iterator
		while (iterator.hasNext) {
			val autoMappingTask = iterator.next
			val guiElem = autoMappingTask.referencedViewField.resolveViewGUIElement
			val overwrite = userMappingTasks.exists(userMappingTask | userMappingTask.referencedViewField.resolveViewGUIElement == guiElem)
			val unmap = unmappingTasks.exists(unMappingTask | unMappingTask.referencedViewField.resolveViewGUIElement == guiElem)
			if (overwrite || unmap) {
				autoMappingTask.remove()
				iterator.remove()
			}
		}
		
		// Replace custom validators with standard validator definitions
		val Iterable<CustomizedValidatorType> validators = workingInput.resources.map(r|r.allContents.toIterable.filter(typeof(CustomizedValidatorType))).flatten
		validators.forEach [ validator |
			val customizedValidatorToReplace = validator.validator
			var StandardValidatorType replacement
			// Get custom validator and create a standard validator from its information
			var StandardValidator newValidator = switch (customizedValidatorToReplace) {
				NotNullValidator: factory.createStandardNotNullValidator
				IsIntValidator: factory.createStandardIsIntValidator
				IsNumberValidator: factory.createStandardIsNumberValidator
				RegExValidator: factory.createStandardRegExValidator
				NumberRangeValidator: factory.createStandardNumberRangeValidator
				StringRangeValidator: factory.createStandardStringRangeValidator
				IsDateValidator: factory.createStandardIsDateValidator
			}
			newValidator.params.addAll(customizedValidatorToReplace.params)
			replacement = factory.createStandardValidatorType
			replacement.validator = newValidator
			validator.replace(replacement)
		]
		
		// Copy user-specified validators from original to cloned/auto-generated GUI elements
		// Restricted to StartupActions		
		val Iterable<ValidatorBindingTask> validatorBindingTasks = workingInput.resources.map(r|r.allContents.toIterable.filter(typeof(ValidatorBindingTask)).filter([isCalledAtStartup(it)])).flatten.toList
		val Collection<ValidatorBindingTask> userValidatorBindingTasks = newHashSet()
		validatorBindingTasks.forEach [ validatorBindingTask |
			for (abstractRef : validatorBindingTask.referencedFields) {
				for (entry : clonedElements.entrySet) {
					if (entry.value == abstractRef.resolveViewGUIElement) {
						val newTask = copyElement(validatorBindingTask) as ValidatorBindingTask
						newTask.referencedFields.clear
						val newAbstractRef = factory.createAbstractViewGUIElementRef()
						newAbstractRef.ref = entry.key
						newTask.referencedFields.add(newAbstractRef)
						val validatorAction = validatorBindingTask.eContainer as CustomAction
						validatorAction.codeFragments.add(newTask)
						userValidatorBindingTasks.add(newTask)
					}
				}
			}
			userValidatorBindingTasks.add(validatorBindingTask)
		]
		
		// Create validators according to model constraints for mapped GUI elements if no user-specified validator with same type is found 
		// Restricted to StartupActions		
		val Collection<ValidatorUnbindTask> unbindTasks = workingInput.resources.map(r|r.allContents.toIterable.filter(typeof(ValidatorUnbindTask)).filter([isCalledAtStartup(it)])).flatten.toList
		mappingTasks = newHashSet()	
		mappingTasks.addAll(userMappingTasks)
		mappingTasks.addAll(autoMappingTasks)
		mappingTasks.filter([(it.pathDefinition as ContentProviderPathDefinition).contentProviderRef.type instanceof ReferencedModelType]).forEach [ mappingTask |
			val validatorBindingTask = modelConstraintToValidator(factory, workingInput, mappingTask)
			val guiElem = mappingTask.referencedViewField.resolveViewGUIElement
			userValidatorBindingTasks.forEach [ userValidatorBindingTask |
				userValidatorBindingTask.referencedFields.filter([it.resolveViewGUIElement == guiElem]).forEach [ abstractRef |
					userValidatorBindingTask.validators.filter(typeof(StandardValidatorType)).forEach [ userValidatorType |
						var ValidatorType removeAutoValidatorType = null		
						for (autoValidatorType : validatorBindingTask.validators) {						
							if ((autoValidatorType as StandardValidatorType).validator.eClass == userValidatorType.validator.eClass) {
								removeAutoValidatorType = autoValidatorType
							}
						}
						removeAutoValidatorType?.remove()
					]
				]
			]
			unbindTasks.forEach [ unbindTask |
				unbindTask.referencedFields.filter([it.resolveViewGUIElement == guiElem]).forEach [ abstractRef |
					if (unbindTask.allTypes) {
						validatorBindingTask.validators.clear()
					}
					//@TODO Implement all ValidatorTypes
				]
			]			
			if (validatorBindingTask.validators.size > 0) {
				getAutoGenAction(workingInput)?.codeFragments.add(validatorBindingTask)
			}
		]		
		
		// Copy user-specified events from original to cloned/auto-generated GUI elements
		// Restricted to StartupActions
		val Iterable<EventBindingTask> eventBindingTasks = workingInput.resources.map(r|r.allContents.toIterable.filter(typeof(EventBindingTask)).filter([isCalledAtStartup(it)])).flatten.toList
		eventBindingTasks.forEach [ eventBindingTask |
			eventBindingTask.events.filter(typeof(ViewElementEventRef)).forEach [ eventRef |
				for (entry : clonedElements.entrySet) {
					if (entry.value == eventRef.referencedField.resolveViewGUIElement) {
						val newTask = copyElement(eventBindingTask) as EventBindingTask
						newTask.events.clear
						val newEventRef = factory.createViewElementEventRef()
						val newAbstractRef = factory.createAbstractViewGUIElementRef()
						newAbstractRef.ref = entry.key
						newEventRef.referencedField = newAbstractRef
						newEventRef.event = eventRef.event
						newTask.events.add(newEventRef)
						val eventBindingAction = eventBindingTask.eContainer as CustomAction
						eventBindingAction.codeFragments.add(newTask)
					}
				}				
			]
		]
		
		// Copy all CustomCodeFragments from regular (non-startup) actions from original to cloned/auto-generated GUI elements
		val Iterable<CustomCodeFragment> nonStartupCodeFragments = workingInput.resources.map(r|r.allContents.toIterable.filter(typeof(CustomCodeFragment)).filter([!isCalledAtStartup(it)])).flatten.toList
		nonStartupCodeFragments.forEach [ codeFragment |
			val codeFragmentAction = codeFragment.eContainer as CustomAction
			switch (codeFragment) {
				EventBindingTask: {
					codeFragment.events.filter(typeof(ViewElementEventRef)).forEach [ eventRef |
						for (entry : clonedElements.entrySet) {
							if (entry.value == eventRef.referencedField.resolveViewGUIElement) {
								val newTask = copyElement(codeFragment) as EventBindingTask
								newTask.events.clear
								val newEventRef = factory.createViewElementEventRef()
								val newAbstractRef = factory.createAbstractViewGUIElementRef()
								newAbstractRef.ref = entry.key
								newEventRef.referencedField = newAbstractRef
								newEventRef.event = eventRef.event
								newTask.events.add(newEventRef)
								codeFragmentAction.codeFragments.add(newTask)
							}
						}				
					]
				}
				EventUnbindTask: {
					codeFragment.events.filter(typeof(ViewElementEventRef)).forEach [ eventRef |
						for (entry : clonedElements.entrySet) {
							if (entry.value == eventRef.referencedField.resolveViewGUIElement) {
								val newTask = copyElement(codeFragment) as EventUnbindTask
								newTask.events.clear
								val newEventRef = factory.createViewElementEventRef()
								val newAbstractRef = factory.createAbstractViewGUIElementRef()
								newAbstractRef.ref = entry.key
								newEventRef.referencedField = newAbstractRef
								newEventRef.event = eventRef.event
								newTask.events.add(newEventRef)
								codeFragmentAction.codeFragments.add(newTask)
							}
						}				
					]
				}
				ValidatorBindingTask: {
					for (abstractRef : codeFragment.referencedFields) {
						for (entry : clonedElements.entrySet) {
							if (entry.value == abstractRef.resolveViewGUIElement) {
								val newTask = copyElement(codeFragment) as ValidatorBindingTask
								newTask.referencedFields.clear
								val newAbstractRef = factory.createAbstractViewGUIElementRef()
								newAbstractRef.ref = entry.key
								newTask.referencedFields.add(newAbstractRef)
								codeFragmentAction.codeFragments.add(newTask)
							}
						}
					}
				}
				ValidatorUnbindTask: {
					for (abstractRef : codeFragment.referencedFields) {
						for (entry : clonedElements.entrySet) {
							if (entry.value == abstractRef.resolveViewGUIElement) {
								val newTask = copyElement(codeFragment) as ValidatorUnbindTask
								newTask.referencedFields.clear
								val newAbstractRef = factory.createAbstractViewGUIElementRef()
								newAbstractRef.ref = entry.key
								newTask.referencedFields.add(newAbstractRef)
								codeFragmentAction.codeFragments.add(newTask)
							}
						}
					}
				}
				MappingTask: {
					for (entry : clonedElements.entrySet) {
						if (entry.value == codeFragment.referencedViewField.resolveViewGUIElement) {		
							val newTask = copyElement(codeFragment) as MappingTask
							val newAbstractRef = factory.createAbstractViewGUIElementRef()
							newAbstractRef.ref = entry.key
							newTask.referencedViewField = newAbstractRef
							codeFragmentAction.codeFragments.add(newTask)
						}
					}
				}
				UnmappingTask: {
					for (entry : clonedElements.entrySet) {
						if (entry.value == codeFragment.referencedViewField.resolveViewGUIElement) {		
							val newTask = copyElement(codeFragment) as UnmappingTask
							val newAbstractRef = factory.createAbstractViewGUIElementRef()
							newAbstractRef.ref = entry.key
							newTask.referencedViewField = newAbstractRef
							codeFragmentAction.codeFragments.add(newTask)
						}
					}
				}						
			}
		]
				
		// Remove redundant elements
		val Collection<EObject> objectsToRemove = newHashSet()
		objectsToRemove.addAll(autoGenerators)
		objectsToRemove.addAll(containerRefs)
		objectsToRemove.addAll(viewRefsDone)
		for (objRemove : objectsToRemove) {
			switch (objRemove) {
				ViewGUIElement: objRemove.eContainer.remove
				ContainerElementRef: objRemove.remove
				ViewElementRef: objRemove.remove				
			}
		}
		
		// Return new ResourceSet
		workingInput.resolveAll
		workingInput
	}
	
	def private static Collection<EntityPathDefinition> entityToPathDefinition(MD2Factory factory, EntityPathDefinition pathDefinition, Entity element) { 
		val Collection<EntityPathDefinition> entityPathes = newHashSet()
		element.attributes.forEach [
			val iterPathDefinition = copyElement(pathDefinition) as EntityPathDefinition
			if (iterPathDefinition.lastPathTail == null) {
				iterPathDefinition.tail = factory.createPathTail() 
			} else {
				iterPathDefinition.lastPathTail.tail = factory.createPathTail()
			}
			iterPathDefinition.lastPathTail.setAttributeRef(it)
			entityPathes.add(iterPathDefinition)
			if (it instanceof ReferencedType && (it as ReferencedType).entity instanceof Entity) {
				entityPathes.addAll(entityToPathDefinition(factory, iterPathDefinition, (it as ReferencedType).entity as Entity))
			}
		]
		entityPathes
	}
	
	/**
	 * Look up pseudo-referenced ViewGUIElement
	 */
	def private static ViewGUIElement resolveAbstractViewGUIElementRef(ResourceSet input, AbstractViewGUIElementRef abstractRef, ViewGUIElement guiElem, HashMap<EObject, EObject> clonedElements) {
		var nextGuiElem = guiElem
		val qualifiedNameProvider = new DefaultDeclarativeQualifiedNameProvider()
		if (abstractRef.ref instanceof ViewGUIElement) {
			if (guiElem == null) {
				nextGuiElem = abstractRef.ref as ViewGUIElement
			} else {
				var qualifiedName = qualifiedNameProvider.getFullyQualifiedName(abstractRef.ref)
				for (searchName : qualifiedName.skipFirst(1).segments) {
					nextGuiElem = nextGuiElem.eAllContents.filter(typeof(ViewGUIElement)).findFirst(searchGuiElem | searchGuiElem.name != null && searchGuiElem.name.equals(searchName))
				}
			}
		} else if (abstractRef.ref instanceof ViewElementType || abstractRef.ref instanceof ContainerElementType) {
			if (guiElem == null) {
				nextGuiElem = abstractRef.ref.eContainer as ViewGUIElement
			}
			val searchName = switch (abstractRef.ref) {
				ViewElementRef: (abstractRef.ref as ViewElementRef).name
				ContainerElementRef: (abstractRef.ref as ContainerElementRef).name
			}
			nextGuiElem = nextGuiElem.eAllContents.filter(typeof(ViewGUIElement)).findFirst(searchGuiElem | searchGuiElem.name != null && searchGuiElem.name.equals(searchName))
		}
		if (nextGuiElem instanceof AutoGeneratedContentElement) {
			val parentGuiElem = nextGuiElem.eContainer.eContainer
			// Use initial mappings
			var Iterable<MappingTask> mappingTasks = getAutoGenAction(input).codeFragments.filter(typeof(MappingTask))
			if (abstractRef.path != null) {
				// ReferencedModelType
				mappingTasks = mappingTasks.toList.filter([it.pathDefinition.referencedAttribute == abstractRef.path.referencedAttribute])
			} else {
				// SimpleType
				mappingTasks = mappingTasks.toList.filter([it.pathDefinition.contentProviderRef.type instanceof SimpleType]).filter([(it.pathDefinition.contentProviderRef.type as SimpleType).type == abstractRef.simpleType.type])
			}
			val Collection<EObject> candidates = newArrayList
			mappingTasks.map([it.referencedViewField.ref]).forEach [ mappedGuiElem |
				candidates.add(mappedGuiElem)
				candidates.addAll(clonedElements.filter([key, value | value.equals(mappedGuiElem)]).keySet)
			]
			nextGuiElem = candidates?.findFirst(candidate | parentGuiElem.isAncestor(candidate)) as ViewGUIElement
		}
		if (abstractRef.getTail != null) {
			return resolveAbstractViewGUIElementRef(input, abstractRef.getTail(), nextGuiElem, clonedElements) 
		} else {
			return nextGuiElem;
		}
	}
	
	def private static Iterable<ViewElementDef> modelToView(MD2Factory factory, ResourceSet input, ModelElement m, ContentProviderPathDefinition pathDefinition, Collection<EntityPathDefinition> filteredAttributes) {
		val List<ViewElementDef> viewElements = Lists::newArrayList
		if (m instanceof Entity) {
			(m as Entity).attributes.forEach [ a |
				val viewElementDef = factory.createViewElementDef()
				// New PathDefinition for every attribute
				val pathDefinitionIter = copyElement(pathDefinition) as ContentProviderPathDefinition
				val PathTail pathTail = factory.createPathTail()
				pathTail.setAttributeRef(a)
				if (pathDefinitionIter.getTail == null) pathDefinitionIter.setTail(pathTail)
				else getLastPathTail(pathDefinitionIter).setTail(pathTail)
				var boolean skip = false
				for (filterPathDefinition : filteredAttributes) {
					if (pathDefinitionIter.equals(filterPathDefinition)) skip = true
				}
				if (!skip) {
//					if (a.type.many) {
//						viewElementDef.value = factory.createEntitySelector()
//						viewElementDef.value.name = a.name + "EntitySelector"
//						(viewElementDef.value as EntitySelector).textProposition = pathDefinitionIter
//					} else {
						switch (a.type) {
							ReferencedType: {
								if ((a.type as ReferencedType).entity instanceof Entity) {
									val flowLayoutPane = factory.createFlowLayoutPane()
									flowLayoutPane.name = a.name + "FlowLayoutPane"
									// Recursive modelToView for references entities
									for (childElem : modelToView(factory, input, (a.type as ReferencedType).entity, copyElement(pathDefinitionIter) as ContentProviderPathDefinition, filteredAttributes)) {
										flowLayoutPane.elements.add(childElem as ViewElementDef)
									}
									flowLayoutPane.params.add(factory.createFlowLayoutPaneFlowDirectionParam)
									(flowLayoutPane.params.get(0) as FlowLayoutPaneFlowDirectionParam).flowDirection = FlowDirection::VERTICAL
									viewElementDef.value = flowLayoutPane
								} else if ((a.type as ReferencedType).entity instanceof Enum) {
									viewElementDef.value = factory.createOptionInput().applyStyle(a)
									viewElementDef.value.name = a.name + "OptionInput"
									(viewElementDef.value as OptionInput).enumReference = ((a.type as ReferencedType).entity as Enum)
								}
							}
							BooleanType: {
								viewElementDef.value = factory.createCheckBox().applyStyle(a)
								viewElementDef.value.name = a.name + "CheckBox"
							}
							case (a.type instanceof IntegerType || a.type instanceof FloatType || a.type instanceof StringType): {
								viewElementDef.value = factory.createTextInput().applyStyle(a)
								viewElementDef.value.name = a.name + "TextInput"
							}
							case (a.type instanceof DateType || a.type instanceof TimeType || a.type instanceof DateTimeType): {
								viewElementDef.value = factory.createTextInput().applyStyle(a)
								viewElementDef.value.name = a.name + "TextInput"
								(viewElementDef.value as TextInput).type = switch a.type {
									DateType: TextInputType::DATE
									TimeType: TextInputType::TIME
									DateTimeType: TextInputType::DATE_TIME
								}
							}
							EnumType: {
								System::err.println("[M2M] Oops: Encountered implicit enum "+a.name+". Should be transformed already.")
							}
							default: {
								System::err.println("[M2M] Oops: Encountered unsupported Attribute type "+a.type.eClass.name+".")
							}
						}
						addDataMapping(factory, input, viewElementDef.value, pathDefinitionIter)				
//					}
					viewElements.add(viewElementDef)							
				}
			]
		}
		viewElements
	}
	
	def private static ViewElementDef modelToView(MD2Factory factory, ResourceSet input, SimpleDataType s, ContentProviderPathDefinition pathDefinition) {
		val viewElementDef = factory.createViewElementDef()
		switch (s) {
			case SimpleDataType::INTEGER: viewElementDef.value = factory.createTextInput()
			case SimpleDataType::FLOAT: viewElementDef.value = factory.createTextInput()
			case SimpleDataType::STRING: viewElementDef.value = factory.createTextInput()
			case SimpleDataType::BOOLEAN: viewElementDef.value = factory.createCheckBox()
			case SimpleDataType::DATE: {
				viewElementDef.value = factory.createTextInput()
				(viewElementDef.value as TextInput).type = TextInputType::DATE
			}
			case SimpleDataType::TIME: {
				viewElementDef.value = factory.createTextInput()
				(viewElementDef.value as TextInput).type = TextInputType::TIME

			}
			case SimpleDataType::DATE_TIME: {
				viewElementDef.value = factory.createTextInput()
				(viewElementDef.value as TextInput).type = TextInputType::DATE_TIME	
			}
		}
		viewElementDef.value.name = pathDefinition.contentProviderRef.name + viewElementDef.value.eClass.name 
		addDataMapping(factory, input, viewElementDef.value, pathDefinition)
		viewElementDef
	}
		
	def private static addDataMapping(MD2Factory factory, ResourceSet input, ViewGUIElement guiElem, ContentProviderPathDefinition pathDefinition) {
		val autoGenAction = getAutoGenAction(input)
		if (autoGenAction == null) return null
		val mappingTask = factory.createMappingTask()
		mappingTask.referencedViewField = factory.createAbstractViewGUIElementRef()
		mappingTask.referencedViewField.ref = guiElem
		mappingTask.pathDefinition = pathDefinition as ContentProviderPathDefinition
		autoGenAction.codeFragments.add(mappingTask)
	}
	
	def private static ValidatorBindingTask modelConstraintToValidator(MD2Factory factory, ResourceSet input, MappingTask mappingTask) {
		val autoGenAction = getAutoGenAction(input)
		val ctrl = input.resources.map(r|r.allContents.toIterable.filter(typeof(Controller))).flatten.last
		if (autoGenAction == null || ctrl == null) return null
		val validatorBindingTask = factory.createValidatorBindingTask()
		validatorBindingTask.referencedFields.add(copyElement(mappingTask.referencedViewField) as AbstractViewGUIElementRef)
		val attr = mappingTask.pathDefinition.getReferencedAttribute
		
		// Add IsNotNullValidator
		if (!attr.type.eAllContents.toIterable.filter(typeof(AttrIsOptional)).exists(attrIsOptional | attrIsOptional.optional)) {
			val isNotNullValidator = factory.createStandardValidatorType
			isNotNullValidator.validator = factory.createStandardNotNullValidator
			validatorBindingTask.validators.add(isNotNullValidator)			
		}
		
		// Add attribute type specific standard validators
		val type = attr.type
		switch type {
			ReferencedType case type.entity instanceof Enum: { 
				// No further standard validators exist for this case
			}
			IntegerType: {
				// set IsIntValidator
				val isIntValidator = factory.createStandardValidatorType
				isIntValidator.validator = factory.createStandardIsIntValidator
				validatorBindingTask.validators.add(isIntValidator)
				
				// set NumberRangeValidator
				if(type.params.exists(p | p instanceof AttrIntMax || p instanceof AttrIntMin)) {
					val numberRangeValidator = factory.createStandardValidatorType
					numberRangeValidator.validator = factory.createStandardNumberRangeValidator
					
					val max = type.params.filter(typeof(AttrIntMax)).last
					val min = type.params.filter(typeof(AttrIntMin)).last
					
					if(max != null) {
						val validatorMaxParam = factory.createValidatorMaxParam
						validatorMaxParam.setMax(max.max)
						numberRangeValidator.validator.params.add(validatorMaxParam)
					}
					if(min != null) {
						val validatorMinParam = factory.createValidatorMinParam
						validatorMinParam.setMin(min.min)
						numberRangeValidator.validator.params.add(validatorMinParam)
					}
					
					validatorBindingTask.validators.add(numberRangeValidator)
				}
			}
			FloatType: {
				// set IsNumberValidator
				val isNumberValidator = factory.createStandardValidatorType
				isNumberValidator.validator = factory.createStandardIsNumberValidator
				validatorBindingTask.validators.add(isNumberValidator)
				
				// set NumberRangeValidator
				if(type.params.exists(p | p instanceof AttrFloatMax || p instanceof AttrFloatMin)) {
					val numberRangeValidator = factory.createStandardValidatorType
					numberRangeValidator.validator = factory.createStandardNumberRangeValidator
					
					val max = type.params.filter(typeof(AttrFloatMax)).last
					val min = type.params.filter(typeof(AttrFloatMin)).last
					
					if(max != null) {
						val validatorMaxParam = factory.createValidatorMaxParam
						validatorMaxParam.setMax(max.max)
						numberRangeValidator.validator.params.add(validatorMaxParam)
					}
					if(min != null) {
						val validatorMinParam = factory.createValidatorMinParam
						validatorMinParam.setMin(min.min)
						numberRangeValidator.validator.params.add(validatorMinParam)
					}
					
					validatorBindingTask.validators.add(numberRangeValidator)
				}
			}
			StringType: {
				// set StringRangeValidator
				if(type.params.exists(p | p instanceof AttrStringMax || p instanceof AttrStringMin)) {
					val stringRangeValidator = factory.createStandardValidatorType
					stringRangeValidator.validator = factory.createStandardStringRangeValidator
					
					val maxLength = type.params.filter(typeof(AttrStringMax)).last
					val minLength = type.params.filter(typeof(AttrStringMin)).last
					
					if(maxLength != null) {
						val validatorMaxLengthParam = factory.createValidatorMaxLengthParam
						validatorMaxLengthParam.setMaxLength(maxLength.max)
						stringRangeValidator.validator.params.add(validatorMaxLengthParam)
					}
					if(minLength != null) {
						val validatorMinLengthParam = factory.createValidatorMinLengthParam
						validatorMinLengthParam.setMinLength(minLength.min)
						stringRangeValidator.validator.params.add(validatorMinLengthParam)
					}
					
					validatorBindingTask.validators.add(stringRangeValidator)
				}
			}
			BooleanType: {
				// No further standard validators exist for this case
			}
			DateType: {
				// TODO - So far there are no MIN/MAX validators for dates and times, but an according model constraint exists
			}
			TimeType: {
				// TODO - So far there are no MIN/MAX validators for dates and times, but an according model constraint exists
			}
			DateTimeType: {
				// TODO - So far there are no MIN/MAX validators for dates and times, but an according model constraint exists
			}
		}
		validatorBindingTask
	}
	
	def static CustomAction getAutoGenAction(ResourceSet input) {
		input.resources.map(r|r.allContents.toIterable.filter(typeof(CustomAction)).filter(action | action.name == autoGenerationActionName)).flatten.last
	}
	
	def private static ContentElement applyStyle(ContentElement contentElement, Attribute attr) {
		val labelText = switch (attr.extendedName) {
			String: attr.extendedName
			default: attr.name.toFirstUpper.replaceAll("(.)([A-Z])","$1 $2")
		}
		switch (contentElement) {
			OptionInput: {
				contentElement.labelText = labelText
				contentElement.tooltipText = attr.description
			}
			TextInput: {
				contentElement.labelText = labelText
				contentElement.tooltipText = attr.description				
			}
			CheckBox: {
				contentElement.labelText = labelText
				contentElement.tooltipText = attr.description						
			}
		}
		contentElement
	}
	
	def static ResourceSet copyModel(ResourceSet input) {
		val ResourceSet workingInput = new ResourceSetImpl()
		val copier = new EcoreUtil$Copier()
		for (resource : input.resources) {
			val workingInputResource = workingInput.createResource(resource.URI)
			workingInputResource.contents.addAll((copier.copyAll(resource.contents)))
			workingInput.resources.add(workingInputResource)
		}
		copier.copyReferences()
		workingInput
	}
	
	def static EObject copyElement(EObject elem) {
		return copyElement(elem, null);
	}
	
	def static EObject copyElement(EObject elem, HashMap<EObject, EObject> map) {
		val copier = new EcoreUtil$Copier()
		val newElem = copier.copy(elem)
		copier.copyReferences
		if (map != null) {
			// Get all copied elements in a Hashset with the copied element as key
			for (entry : copier.entrySet) {
				map.put(entry.value, entry.key)
			}	
		}		
		newElem
	}
	
	def private static int countContainers(EObject obj, int i) {
		if (obj.eContainer != null) {
			countContainers(obj.eContainer, i+1)
		} else {
			return i;
		} 
	}
	
	def private static Workflow processWorkflowMerging(Workflow workflow, Iterable<GotoWorkflowStepAction> gotoWfStepAction, MD2Factory factory) {
		// copy actual wf step list to avoid ConcurrentModificationException...
		val workflowStepsCopy = <WorkflowStep>newArrayList
		workflowStepsCopy.addAll(workflow.workflowSteps)
		
		// collect steps to remove
		val stepsToRemove = <WorkflowStep>newHashSet
		
		// ...but operate on original wf step list
		for(step : workflowStepsCopy) {
			if(step.subworkflow != null) {
				// replace workflow step with actual subworkflow
				val idx = workflow.workflowSteps.indexOf(step)
				var i = 0
				for(subStep : step.subworkflow.processWorkflowMerging(gotoWfStepAction, factory).workflowSteps) {
					val copiedSubStep = subStep.copyElement as WorkflowStep
					copiedSubStep.setName(step.name + "_" + copiedSubStep.name)
					workflow.workflowSteps.add(idx + i, copiedSubStep)
					i = i + 1
				}
				
				// replace all references to this step with the first step of the subworkflow
				// and remove current wf step
				for (action : gotoWfStepAction.filter(a | a.wfStep.equals(step))) {
					if(step.subworkflow.workflowSteps.size > 0) {
						action.setWfStep(workflow.workflowSteps.get(idx))
					}
				}
				stepsToRemove.add(step)
				
				
				// Duplicate Workflow.gotoToStepAction so that it references to all sub workflows
				for (action : gotoWfStepAction.filter(a | a.wfStep.eContainer.equals(step.subworkflow))) {
					// build new action
					val newGotoWfStepAction = factory.createGotoWorkflowStepAction
					newGotoWfStepAction.setSilentFails(true)
					newGotoWfStepAction.setWfStep(workflow.workflowSteps.filter(s | s.name.equals(step.name + "_" + action.wfStep.name)).last)
					val newSimpleActionRef = factory.createSimpleActionRef
					newSimpleActionRef.setAction(newGotoWfStepAction)
					
					// add new action for duplicated Wf step
					val actionContainer = action.eContainer.eContainer
					switch (actionContainer) {
						EventBindingTask: actionContainer.actions.add(newSimpleActionRef)
						EventUnbindTask: actionContainer.actions.add(newSimpleActionRef)
						CallTask: {
							val customAction = actionContainer.eContainer as CustomAction
							val newCallTask = factory.createCallTask
							newCallTask.setAction(newSimpleActionRef)
							customAction.codeFragments.add(customAction.codeFragments.indexOf(actionContainer), newCallTask)
						}
					}
				}
			}
		}
		
		workflow.workflowSteps.removeAll(stepsToRemove)
		workflow
	}
	
	def private static initializeColorNameHexMap() {
		val Map<NamedColor, String> map = newHashMap
		map.put(NamedColor::AQUA, "#00ffff")
		map.put(NamedColor::BLACK, "#000000")
		map.put(NamedColor::BLUE, "#0000ff")
		map.put(NamedColor::FUCHSIA, "#ff00ff")
		map.put(NamedColor::GRAY, "#808080")
		map.put(NamedColor::GREEN, "#008000")
		map.put(NamedColor::LIME, "#00ff00")
		map.put(NamedColor::MAROON, "#800000")
		map.put(NamedColor::NAVY, "#000080")
		map.put(NamedColor::OLIVE, "#808000")
		map.put(NamedColor::PURPLE, "#800080")
		map.put(NamedColor::RED, "#ff0000")
		map.put(NamedColor::SILVER, "#c0c0c0")
		map.put(NamedColor::TEAL, "#008080")
		map.put(NamedColor::WHITE, "#ffffff")
		map.put(NamedColor::YELLOW, "#ffff00")
		colorNameHexMap = Collections::unmodifiableMap(map)
	}

}
